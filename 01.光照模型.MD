# 光照模型

基本模型 = 直接漫反射 + 高光 + 间接漫反射 + 间接镜面反射

## 01. 前向渲染

### 前向渲染特点
前向渲染的特点为需要两个Pass：
1.每个物体调用ForwardBase的Pass渲染平行光
2.每个物体调用ForwardAdd的Pass叠加方式渲染所有光（包含平行光）
第二个pass采用Blend One One的形式混合

这种渲染模式 算法轻量级 适用于轻量级平台 但光源越多计算量越大
当光源数量超出质量设定里的数量 将采用顶点光模式渲染
增加光强或者更改important可以设定重要程度

### 前向渲染Shader编写格式

```C++
//第一个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardBase"}
    ...
    CGPROGRAM
    #pragma multi_compile_fwdbase // 必须的引用
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
           ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
           ... 
    }
    ...
    ENDCG
}

//第二个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardAdd"}
    Blend One One
    ...
    CGPROGRAM
    // 必须的引用
    #pragma multi_compile_fwdadd 

    #include "UnityCG.cginc"
    #include "AutoLight.cginc"
    #include "Lighting.cginc"
    ...
    // float4 _LightColor0; //  #include "Lighting.cginc" 时则不用定义
    ...
    float4 frag(v2f i) : SV_Target{
            ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
            ... 

            //_WorldSpaceLightPos0.w也可以用于判断光源类型
            #ifdef USING_DIRECTIONAL_LIGHT// AutoLight的宏定义 平行光
            float3 light_dir = normalize(_WorldSpaceLightPos0);
            float attention = 1.0;
            #else // AutoLight的宏定义 点光源
            float3 light_dir = normalize(_WorldSpaceLightPos0 - worldPos);
            float distance = length(_WorldSpaceLightPos0 - worldPos);
            //衰减范围获取（oldVersion） NewVersion参考阴影
            float range = 1.0 / unity_WorldToLight[0][0]; 
            float attention = saturate((range - distance)/range);
            #endif 
    }
    ...
    ENDCG
}
```

> 注意Tex2D() 和 for循环 耗性能 能少用就少用

## 02. 直接光照

#### 漫反射贴图

> dot (光源方向 , 法线) * 贴图

```C++
sampler2D _MainTex;
float4 _MainTex_ST;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : NORMAL;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    ...
}

float4 frag(v2f i) : SV_Target{
    float4 mainTex = tex2D(_MainTex, i.uv);
    float3 normal = normalize(i.normal);
    float lightModel = max(0,dot(light_dir, normal));
    float3 diffuse = mainTex * lightModel;
}
```

#### 法线贴图
> 贴图Unpack后使用xzy分别对切线 法线 和cross(法线,切线)的线 作用 当作新的法线

```C++
Properties
{
    ...
    _NormalMap("NormalMap", 2D) = "bump" {}
    _NormalInensity("NormalInensity",Range(0,1.0)) = 1.0
    ...
}
sampler2D _NormalMap;
float _NormalInensity;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : TEXCOORD1;
    float3 tangent : TEXCOORD2;
    float3 binormal : TEXCOORD3;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = UnityObjectToWorldNormal(v.normal); // normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    o.tangent = normalize(mul(unity_ObjectToWorld, v.tangent));
    ...
}

float4 frag(v2f i) : SV_Target{
    float3 binormal = cross(i.normal, i.tangent.xyz) * i.tangent.w;
    float4 normalMap = tex2D(_NormalMap, uv_parallax);
    float3 normal_data = UnpackNormal(normalMap);
    float3 normal = normalize(i.tangent * normal_data.x * _NormalInensity + binormal * normal_data.y * _NormalInensity + i.normal * normal_data.z);
}
```

#### 高光与高光Mask贴图
> pow (dot(视线方向,反射光线) , 强度)* mask贴图  + 漫反射

```C++
float4 frag(v2f i) : SV_Target{
    float3 reflect_dir = reflect(-light_dir, normal);
    float3 spec_color = max(0, dot(reflect_dir, view_dir));
    spec_color = pow(spec_color, _Shininess) * _SpecInensity * speceMaskMap.rgb;
}
```

#### AO贴图
> aoMap.xyz * 输出前的最终颜色

```C++
#include "Lighting.cginc" //_LightColor0

float4 frag(v2f i) : SV_Target{
    float3 finalColor = (diffuse + spec_color ) * _LightColor0.xyz * aoMap.xyz;
}
```

#### 高度贴图
> 偏移UV坐标 后面所有贴图用次UV采样

```C++
float4 frag(v2f i) : SV_Target{
    float3 view_dir = normalize(_WorldSpaceCameraPos - worldPos);
    float3 view_tangentSpace = normalize(mul(TBN,view_dir)) ;
    float2 uv_parallax = i.uv;
    float j = 0;
    //一般不使用for循环 使用重复几次就行
    for(j = 0; j<10 ;j++){
        float4 heightMap = tex2D(_ParallaxMap, uv_parallax);
        uv_parallax = uv_parallax - (1.0 - heightMap) * (view_tangentSpace.xy / view_tangentSpace.z) *_ParallaxInensity *0.01;
    }
}
```

#### 阴影贴图
> 必须要有ShadowCaster ——懒得写可以加上Fallback，会自动补全 o.pos需要配合 o.pos = UnityObjectToClipPos(v.vertex);
```C++
#include "AutoLight.cginc"
//只计算阴影
SHADOW_COORDS(3); //v2f 参数表示TEXCOORD几
TRANSFER_SHADOW(o); //vert
SHADOW_ATTENUATION(i); //frag
//处理投影、而且帮你判断灯光类型、从而算出光照的衰减范围、cookies等
LIGHTING_COORDS(3,4);
TRANSFER_VERTEX_TO_FRAGMENT(o);
LIGHT_ATTENUATION(i);
//计算投影、处理实时投影和静态投影的混合、光照范围和衰减、cookies等
UNITY_SHADOW_COORDS(2);
UNITY_TRANSFER_SHADOW(o, v.uv1);
UNITY_LIGHT_ATTENUATION(atten, i,s.posWorld); // atten直接可以用
```

#### 高动态范围（一般在后期中实现 仅学习不使用）
```C++
float3 ACESFilm(float3 x){
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate((x*(a*x + b)) / (x*(c*x + d) + e));
}

float4 frag(v2f i) : SV_Target{
    ...
    mainTex = pow (mainTex,2.2);
    ...
    finalColor = ACESFilm(finalColor);
	finalColor = pow(finalColor , 1.0 /2.2);
    ...
}
```

## 03. 间接光照

#### 环境光颜色
```C++
float4 frag(v2f i) : SV_Target{
    float3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;
    finalColor += ambient* _AmbientInensity;
}
```

#### 间接镜面反射 CubeMap与反射探针
```C++
float4 frag(v2f i) : SV_Target{
    //反射探针 Cube0全局 Cube1模型受影响的
    //Unity已经做了计算把插值值存在了unity_SpecCube0_BoxMin的第四个分量w。w为1只是第一个探针，值小于1开始混合。
    float4 env_color = UNITY_SAMPLE_TEXCUBE(unity_SpecCube0, reflect(-view_dir, normal));
    float3 env_decode_color = DecodeHDR(env_color, unity_SpecCube0_HDR);
    //CubeMap采样
    float4 env_color = texCube(_CubeMap, reflect(-view_dir, normal));
    float3 env_decode_color = DecodeHDR(env_color, _CubeMap_HDR);
}
```
#### 间接镜面反射 IBL技术(反射探针自带) & 粗糙度贴图 
> Cube贴图 -> Mapping -> Convlution Type -> Specular

```C++
float4 frag(v2f i) : SV_Target{
    float roughnessTex = tex2D(_RoughnessMap , i.uv);
    roughnessTex = saturate(pow(roughnessTex,_RoughnessContrast) * _RoughnessIns); // 增强对比度和亮度
    roughnessTex = lerp(0,1,roughnessTex);
    float mip_level =roughnessTex *6.0; //一般用到6 一共有9 
    float4 env_color = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflect(-view_dir, normal),mip_level);
    float3 env_decode_color = DecodeHDR(env_color, unity_SpecCube0_HDR);
}
```

#### 间接漫反射 LightProbe SH球谐光照 
```C++
struct v2f
{
    float3  SHLighting : COLOR;
};

v2f vert(appdata v)
{
    o.SHLighting = ShadeSH9(float4(o.normal, 1)); // UnityObjectToWorldNormal(v.normal); 
}

float4 frag(v2f i) : SV_Target{
    col += i.SHLighting * mainTex;
}
```

#### Bake & LightMap 

```C++

struct appdata
{
    float2 uv_light : TEXCOORD1; //light map texture uv
};

struct v2f
{
    float4 uv : TEXCOORD1; //light map texture uv
};

v2f vert(appdata v)
{
    o.uv.zw = (v.uv_light.xy * unity_LightmapST.xy + unity_LightmapST.zw);  
}

float4 frag(v2f i) : SV_Target{
#if defined(LIGHTMAP_ON) && defined(SHADOWS_SHADOWMASK) 
    //MixedLight
    float3 c_lm = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.uv.zw));
#elif defined(LIGHTMAP_ON) && !defined(SHADOWS_SHADOWMASK) 
    //BakedLight

#elif defined(LIGHTMAP_OFF) 
    //realtime light
    
#endif
}
```