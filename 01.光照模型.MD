# 光照模型

> 注意Tex2D() 和 for循环 耗性能 能少用就少用

## 01. 经典的光照案例

### 常用PBR案例

#### 贴图漫反射

> dot (光源方向 , 法线) * 贴图

```C++
sampler2D _MainTex;
float4 _MainTex_ST;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : NORMAL;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    ...
}

float4 frag(v2f i) : SV_Target{
    float4 mainTex = tex2D(_MainTex, i.uv);
    float3 normal = normalize(i.normal);
    float lightModel = max(0,dot(light_dir, normal));
    float3 diffuse = mainTex * lightModel;
}
```

#### 法线贴图
> 贴图Unpack后使用xzy分别对切线 法线 和cross(法线,切线)的线 作用 当作新的法线

```C++
Properties
{
    ...
    _NormalMap("NormalMap", 2D) = "bump" {}
    _NormalInensity("NormalInensity",Range(0,1.0)) = 1.0
    ...
}
sampler2D _NormalMap;
float _NormalInensity;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : TEXCOORD1;
    float3 tangent : TEXCOORD2;
    float3 binormal : TEXCOORD3;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    o.tangent = mul(unity_ObjectToWorld,v.tangent);
    o.binormal = cross(o.normal ,o.tangent) * v.tangent.w; // * v.tangent.w 是兼容问题解决
    ...
}

float4 frag(v2f i) : SV_Target{
    float4 mainTex = tex2D(_MainTex, i.uv);
    float3 normal = normalize(i.normal);
    float4 normalMap = tex2D(_NormalMap, i.uv);
    float3 normal_data = UnpackNormal(normalMap);
    //方法一
    normal =normalize(i.tangent * normal_data.x * _NormalInensity + i.binormal  * normal_data.y * _NormalInensity + normal * normal_data.z);
    //方法二
    float3x3 TBN = float3x3(i.tangent, i.binormal, normal);
    normal = normalize(mul(normal_data,TBN)) * _NormalInensity;
}
```

#### 高光与高光Mask贴图
> pow (dot(视线方向,反射光线) , 强度)* mask贴图  + 漫反射

```C++
float4 frag(v2f i) : SV_Target{
    float3 reflect_dir = reflect(-light_dir, normal);
    float3 spec_color = max(0, dot(reflect_dir, view_dir));
    spec_color = pow(spec_color, _Shininess) * _SpecInensity * speceMaskMap.rgb;
}
```

#### AO贴图
> aoMap.xyz * 输出前的最终颜色

```C++
float4 frag(v2f i) : SV_Target{
    float3 finalColor = (diffuse + spec_color ) * _LightColor0.xyz * aoMap.xyz;
}
```

#### 高度贴图
> 偏移UV坐标 后面所有贴图用次UV采样

```C++
float4 frag(v2f i) : SV_Target{
    float3 view_dir = normalize(_WorldSpaceCameraPos - i.pos);
    float3 view_tangentSpace = normalize(mul(TBN,view_dir)) ;
    float2 uv_parallax = i.uv;
    float j = 0;
    //一般不使用for循环 使用重复几次就行
    for(j = 0; j<10 ;j++){
        float4 heightMap = tex2D(_ParallaxMap, uv_parallax);
        uv_parallax = uv_parallax - (1.0 - heightMap) * (view_tangentSpace.xy / view_tangentSpace.z) *_ParallaxInensity *0.01;
    }
}
```

#### 动态范围（一般在后期中实现 仅学习不使用）
```C++
float3 ACESFilm(float3 x){
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate((x*(a*x + b)) / (x*(c*x + d) + e));
}

float4 frag(v2f i) : SV_Target{
    ...
    mainTex = pow (mainTex,2.2);
    ...
    finalColor = ACESFilm(finalColor);
	finalColor = pow(finalColor , 1.0 /2.2);
    ...
}
```


## 02. 前向渲染

### 前向渲染特点
前向渲染的特点为需要两个Pass：
1.每个物体调用ForwardBase的Pass渲染平行光
2.每个物体调用ForwardAdd的Pass叠加方式渲染所有光（包含平行光）
第二个pass采用Blend One One的形式混合

这种渲染模式 算法轻量级 适用于轻量级平台 但光源越多计算量越大
当光源数量超出质量设定里的数量 将采用顶点光模式渲染
增加光强或者更改important可以设定重要程度

### 前向渲染Shader编写格式

```C++
//第一个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardBase"}
    ...
    CGPROGRAM
    #pragma multi_compile_fwdbase // 必须的引用
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
           ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
           ... 
    }
    ...
    ENDCG
}

//第二个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardAdd"}
    Blend One One
    ...
    CGPROGRAM
    // 必须的引用
    #pragma multi_compile_fwdadd 
    #include "AutoLight.cginc"
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
            ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
            ... 
            #if defined(DIRECTIONAL) // AutoLight的宏定义 平行光
            float3 light_dir = normalize(_WorldSpaceLightPos0);
            float attention = 1.0;
            #elif defined(POINT) // AutoLight的宏定义 点光源
            float3 light_dir = normalize(_WorldSpaceLightPos0 - i.pos);
            float distance = length(_WorldSpaceLightPos0 - i.pos);
            float range = 1.0 / unity_WorldToLight[0][0]; //衰减范围获取（oldVersion）
            float attention = saturate((range - distance)/range);
            #endif 
    }
    ...
    ENDCG
}
```