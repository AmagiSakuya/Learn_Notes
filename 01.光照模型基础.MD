# 光照模型基础

基本模型 = 直接漫反射 + 高光 + 间接漫反射 + 间接镜面反射

## 直接光照

#### 漫反射贴图

> dot (光源方向 , 法线) * 贴图

```C++
sampler2D _MainTex;
float4 _MainTex_ST;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : NORMAL;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    ...
}

float4 frag(v2f i) : SV_Target{
    float4 mainTex = tex2D(_MainTex, i.uv);
    float3 normal = normalize(i.normal);
    float lightModel = max(0,dot(light_dir, normal));
    float3 diffuse = mainTex * lightModel;
}
```

#### 法线贴图
> 贴图Unpack后使用xzy分别对切线 法线 和cross(法线,切线)的线 作用 当作新的法线

```C++
Properties
{
    ...
    _NormalMap("NormalMap", 2D) = "bump" {}
    _NormalInensity("NormalInensity",Range(0,1.0)) = 1.0
    ...
}
sampler2D _NormalMap;
float _NormalInensity;

struct appdata
{
    ...
    float2 uv : TEXCOORD0;
    float3 normal : TEXCOORD1;
    float3 tangent : TEXCOORD2;
    float3 binormal : TEXCOORD3;
    ...
};

v2f vert(appdata v)
{
    ...
    o.normal = UnityObjectToWorldNormal(v.normal); // normalize(mul(v.normal, unity_WorldToObject)); // 顺序需要注意 法线在前
    o.uv = TRANSFORM_TEX(v.uv, _MainTex);
    o.tangent = normalize(mul(unity_ObjectToWorld, v.tangent));
    ...
}

float4 frag(v2f i) : SV_Target{
    float3 binormal = cross(i.normal, i.tangent.xyz) * i.tangent.w;
    float4 normalMap = tex2D(_NormalMap, uv_parallax);
    float3 normal_data = UnpackNormal(normalMap);
    float3 normal = normalize(i.tangent * normal_data.x * _NormalInensity + binormal * normal_data.y * _NormalInensity + i.normal * normal_data.z);
}
```

####  金属度贴图 

> (金属度与高光是不同的工作流 都是控制高光的办法 用其中一种即可)

金属只有镜面反射

非金属有全部的光照 包括直接和间接镜面反射
```C++
float4 frag(v2f i) : SV_Target{
    float metal = maskTex.g;
    float4 albedo = tex2D(_MainTex, i.uv);
    //区分金属部分 金属部分 只有金属部分参与高光计算
    float3 base_metal_color = lerp(0, albedo, metal);
}
```

#### 高光
> pow (dot(视线方向,反射光线) , 强度)* mask贴图  + 漫反射

```C++
float4 frag(v2f i) : SV_Target{

    //Phong 模型 耗性能
    float3 reflect_dir = reflect(-light_dir, normal);
    float3 spec_color = max(0, dot(reflect_dir, view_dir));
    //Blinn-phong 模型
    float3 reflect_dir = normalize(data.light_dir + data.view_dir);
    float3 spec_color_model = max(0.0, dot(reflect_dir, data.normal));
    spec_color_model = pow(spec_color_model, 100.0 - _SpecRange * 100.0) ;

    //带smoothness写法
    float3 blin_reflect_dir = normalize(light_dir + view_dir);
    float NdotR = dot(normal, blin_reflect_dir);
    float smoothness = 1.0 - roughness; //roughness 粗糙度贴图
    float shininess = lerp(1, _SpecSmooth, smoothness);
    float3 spec_color_model = pow(max(0.0, NdotR), shininess * smoothness);
    float3 directSpec = base_metal_color * spec_color_model * _LightColor0 * _SpecInensity;
}
```

#### AO贴图
> aoMap.xyz * 输出前的最终颜色

```C++
#include "Lighting.cginc" //_LightColor0

float4 frag(v2f i) : SV_Target{
    float3 finalColor = (diffuse + spec_color ) * _LightColor0.xyz * aoMap.xyz;
}
```

#### 高度贴图
> 偏移UV坐标 后面所有贴图用次UV采样

```C++
float4 frag(v2f i) : SV_Target{
    float3 view_dir = normalize(_WorldSpaceCameraPos - worldPos);
    float3 view_tangentSpace = normalize(mul(TBN,view_dir)) ;
    float2 uv_parallax = i.uv;
    float j = 0;
    //一般不使用for循环 使用重复几次就行
    for(j = 0; j<10 ;j++){
        float4 heightMap = tex2D(_ParallaxMap, uv_parallax);
        uv_parallax = uv_parallax - (1.0 - heightMap) * (view_tangentSpace.xy / view_tangentSpace.z) *_ParallaxInensity *0.01;
    }
}
```

#### 阴影贴图
> 必须要有ShadowCaster ——懒得写可以加上Fallback，会自动补全 o.pos需要配合 o.pos = UnityObjectToClipPos(v.vertex);
```C++
#include "AutoLight.cginc"
//只计算阴影
SHADOW_COORDS(3) //v2f 参数表示TEXCOORD几
TRANSFER_SHADOW(o); //vert
SHADOW_ATTENUATION(i); //frag
//处理投影、而且帮你判断灯光类型、从而算出光照的衰减范围、cookies等
LIGHTING_COORDS(3,4)
TRANSFER_VERTEX_TO_FRAGMENT(o);
LIGHT_ATTENUATION(i);
//计算投影、处理实时投影和静态投影的混合、光照范围和衰减、cookies等
UNITY_SHADOW_COORDS(2)
UNITY_TRANSFER_SHADOW(o, v.uv1);
UNITY_LIGHT_ATTENUATION(atten, i,s.posWorld); // atten直接可以用
```


#### 高动态范围（一般在后期中实现 仅学习不使用）
```C++
float3 ACESFilm(float3 x){
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return saturate((x*(a*x + b)) / (x*(c*x + d) + e));
}

float4 frag(v2f i) : SV_Target{
    ...
    mainTex = pow (mainTex,2.2);
    ...
    finalColor = ACESFilm(finalColor);
	finalColor = pow(finalColor , 1.0 /2.2);
    ...
}
```

## 间接光照

#### 环境光颜色
```C++
float4 frag(v2f i) : SV_Target{
    float3 ambient = UNITY_LIGHTMODEL_AMBIENT.rgb;
    finalColor += ambient* _AmbientInensity;
}
```

#### 间接镜面反射/ 粗造度/CubeMap与反射探针采样
```C++
_CubeMap("CubeMap",CUBE) = ""{}
samplerCUBE _CubeMap;
float4 _CubeMap_HDR;

float4 frag(v2f i) : SV_Target{
    //反射探针 Cube0全局 Cube1模型受影响的
    //Unity已经做了计算把插值值存在了unity_SpecCube0_BoxMin的第四个分量w。w为1只是第一个探针，值小于1开始混合。
    float4 env_color = UNITY_SAMPLE_TEXCUBE(unity_SpecCube0, reflect(-view_dir, normal));
    float3 env_decode_color = DecodeHDR(env_color, unity_SpecCube0_HDR);
    //CubeMap采样
    float4 env_color = texCUBE(_CubeMap, reflect(-view_dir, normal));
    float3 env_decode_color = DecodeHDR(env_color, _CubeMap_HDR);

    //扩展- 粗糙度
    float4 roughness = tex2D(_Roughness, data.uv_parallax);
    roughness = saturate(pow(roughness, _RoughnessContrast) * _RoughnessBrightness);
    roughness = lerp(_RoughnessMin, _RoughnessMax, roughness);
    roughness = roughness * (1.7 - 0.7 * roughness);
    float miplevel = roughness * 9.0;

    float4 env_color = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflect(-data.view_dir, data.normal) , roughness);
    return DecodeHDR(env_color, unity_SpecCube0_HDR);
}
```
#### 间接镜面反射 IBL技术(反射探针自带) & 粗糙度贴图 
> Cube贴图 -> Mapping -> Convlution Type -> Specular

```C++
float4 frag(v2f i) : SV_Target{
    float roughnessTex = tex2D(_RoughnessMap , i.uv);
    roughnessTex = saturate(pow(roughnessTex,_RoughnessContrast) * _RoughnessIns); // 增强对比度和亮度
    roughnessTex = lerp(0,1,roughnessTex);
    float mip_level =roughnessTex *6.0; //一般用到6 一共有9 
    float4 env_color = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflect(-view_dir, normal),mip_level);
    float3 env_decode_color = DecodeHDR(env_color, unity_SpecCube0_HDR);
}
```

#### 间接漫反射 LightProbe SH球谐光照 
```C++
struct v2f
{
    float3  SHLighting : COLOR;
};

v2f vert(appdata v)
{
    o.SHLighting = ShadeSH9(float4(o.normal, 1)); // UnityObjectToWorldNormal(v.normal); 
}

float4 frag(v2f i) : SV_Target{
    col += i.SHLighting * mainTex;
}
```

#### Bake & LightMap 

```C++

struct appdata
{
    float2 uv_light : TEXCOORD1; //light map texture uv
};

struct v2f
{
    float4 uv : TEXCOORD1; //light map texture uv
};

v2f vert(appdata v)
{
    o.uv.zw = (v.uv_light.xy * unity_LightmapST.xy + unity_LightmapST.zw);  
}

float4 frag(v2f i) : SV_Target{
#if defined(LIGHTMAP_ON) && defined(SHADOWS_SHADOWMASK) 
    //MixedLight
    float3 c_lm = DecodeLightmap(UNITY_SAMPLE_TEX2D(unity_Lightmap, i.uv.zw));
#elif defined(LIGHTMAP_ON) && !defined(SHADOWS_SHADOWMASK) 
    //BakedLight

#elif defined(LIGHTMAP_OFF) 
    //realtime light
    
#endif
}
```

#### 间接光烘培 往Lightmap写入材质颜色 增加弹射颜色

```C++

Pass
{
    Name "Meta"
    Tags {"LightMode" = "Meta"}
    Cull Off

    CGPROGRAM
    #pragma vertex vert_meta
    #pragma fragment frag_meta

    #include "Lighting.cginc"
    #include "UnityMetaPass.cginc"

    struct v2f
    {
        float4 pos:SV_POSITION;
        float2 uv:TEXCOORD1;
        float3 worldPos:TEXCOORD0;
    };

    uniform fixed4 _Color;
    uniform sampler2D _MainTex;
    v2f vert_meta(appdata_full v)
    {
        v2f o;
        UNITY_INITIALIZE_OUTPUT(v2f,o);
        o.pos = UnityMetaVertexPosition(v.vertex,v.texcoord1.xy,v.texcoord2.xy,unity_LightmapST,unity_DynamicLightmapST);
        o.uv = v.texcoord.xy;
        return o;
    }

    fixed4 frag_meta(v2f IN) :SV_Target
    {
            UnityMetaInput metaIN;
            UNITY_INITIALIZE_OUTPUT(UnityMetaInput,metaIN);
            metaIN.Albedo = tex2D(_MainTex,IN.uv).rgb * _Color.rgb;
            metaIN.Emission = 0;
            return UnityMetaFragment(metaIN);
    }

    ENDCG

}
```

