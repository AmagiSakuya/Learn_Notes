# 三面映射

因为UV不合适 强行将贴图 以盒状映射到模型上的算法

```C++
float4 frag(v2f i) : SV_Target
{
    // World Space
    // float3 world_origin = mul(unity_ObjectToWorld,float3(0,0,0));
    // float3 m_substance = i.world_pos.xyz - world_origin;
    // float3 m_normal = i.world_normal;
    
    //Object Space
    float3 object_pos = mul(unity_WorldToObject,i.world_pos);
    float3 m_substance = object_pos.xyz - float3(0,0,0);
    float3 m_normal = mul(unity_WorldToObject, i.world_normal);

    float3 nsign = sign(m_normal);
    //三次采样
    float4 colXY = tex2D(_MainTex, float2(-nsign.z, 1.0) * m_substance.xy * _MainTex_ST.xy + _MainTex_ST.zw);
    float4 colXZ = tex2D(_MainTex, float2(nsign.y, 1.0) * m_substance.xz * _MainTex_ST.xy + _MainTex_ST.zw);
    float4 colZY = tex2D(_MainTex, float2(nsign.x, 1.0) * m_substance.zy * _MainTex_ST.xy + _MainTex_ST.zw);

    //如果是法线贴图
    colZY.xyz = half3(UnpackNormal(colZY).xy * float2(nsign.x, 1.0) + m_normal.zy, m_normal.x).zyx;
    colXZ.xyz = half3(UnpackNormal(colXZ).xy * float2(nsign.y, 1.0) + m_normal.xz, m_normal.y).xzy;
    colXY.xyz = half3(UnpackNormal(colXY).xy * float2(-nsign.z, 1.0) + m_normal.xy, m_normal.z).xyz;

    //使用法线混合
    float3 projNormal = pow(abs(m_normal), _BlendPow);
    projNormal /= (projNormal.x + projNormal.y + projNormal.z) + 0.00001;
    float3 triplan = projNormal.x * colZY.rgb + projNormal.y * colXZ.rgb + projNormal.z * colXY.rgb;
    return float4(triplan,1);
}
```