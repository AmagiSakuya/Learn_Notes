# 03.移动端角色渲染

Unity导入模型会压缩动画

导入选项中 - Animation Ani.Compression 选择OFF

## 低成本SSS_Skin渲染

[参考知乎](https://zhuanlan.zhihu.com/p/35628106)
![](./Resource/03.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%92%E8%89%B2%E6%B8%B2%E6%9F%93/diffusescatteringonring_gamma.png)
```C++
float diffuse_term = max(0, dot(light_dir, normal));
float cuv = saturate(_CurveFactor * (length(fwidth(worldnormal)) / length(fwidth(i.worldPos))));
float2 skinUV = float2(diffuse_term * 0.5 + 0.5, cuv);
//使用Ramp图增加次表面散射
float3 sssSkinRamp = tex2D(_SSS_Skin_RampMap, skinUV) * skinMask;
float3 directDiffuse = (albedo * sssSkinRamp + albedo * (1.0 - skinMask) * diffuse_term) * atten  * _LightColor0.rgb;
```

## 油脂层高光
![](./Resource/03.%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%A7%92%E8%89%B2%E6%B8%B2%E6%9F%93/beckmannTex.jpg)
```C++
// 皮肤油脂
float3 L = normalize(_WorldSpaceLightPos0 - i.worldPos);
float3 h = L + view_dir;
float3 H = normalize(h);
float NoH = dot(normal , H);
float3 test =2.0* tex2D(_KelemenLUT,float2(NoH, roughness));
//采样LUT图
float PH = pow(2.0 * tex2D(_KelemenLUT,saturate(float2(NoH, roughness))) , 10.0 );
float F = 0.028;//fresnelReflectance( H, view_dir, 0.028 );
float3 frSpec = max( PH * F / dot( h, h ), 0 ) * _KelemenScale;
float3 res = dot(normal,L) * _KelemenBrightness * frSpec *  skinMask * directDiffuse;

```

## 离线SH间接光照

> 配合计算工具使用 CubemapSHProjector.cs SphericalHarmonicsCoefficient.cs

```C++
custom_SHAr("Custom SHAr", Vector) = (0,0,0,0)
custom_SHAg("Custom SHAg",Vector) = (0,0,0,0)
custom_SHAb("Custom SHAb",Vector) = (0,0,0,0)
custom_SHBr("Custom SHBr",Vector) = (0,0,0,0)
custom_SHBg("Custom SHBg", Vector) = (0,0,0,0)
custom_SHBb("Custom SHBb",Vector) = (0,0,0,0)
custom_SHC("Custom SHC", Vector)= (0,0,0,1)

float4 custom_SHAr;
float4 custom_SHAg;
float4 custom_SHAb;
float4 custom_SHBr;
float4 custom_SHBg;
float4 custom_SHBb;
float4 custom_SHC;

float3 custoumSH(float3 normal) {
    float4 normalForSH = float4(normal, 1.0);
    half3 x;
    x.r = dot(custom_SHAr, normalForSH); 
    x.g = dot(custom_SHAg, normalForSH); 
    x.b = dot(custom_SHAb, normalForSH);
    half3 x1,x2;
    half4 vB = normalForSH.xyzz * normalForSH.yzzx; 
    x1.r = dot(custom_SHBr,vB);
    x1.g = dot(custom_SHBg,vB); 
    x1.b = dot(custom_SHBb, vB);

    half vC = normalForSH.x * normalForSH.x - normalForSH.y * normalForSH.y;
    x2 = custom_SHC.rgb * vC;

    float3 sh = max(float3(0.0,0.0,0.0),(x + x1 + x2)); 
    sh = pow(sh,1.0 / 2.2);
    return sh;
}
```

## 头发各向异性高光

```C++
float uv_aniso = i.uv * _AnisoMap_ST.xy + _AnisoMap_ST.zw;
float aniso_noise = (tex2D(_AnisoMap, uv_aniso).r - 0.5)*2;

float3 half_dir = normalize(light_dir + view_dir);
float  NdotH = dot(normal , half_dir);
float TdotH = dot(half_dir,i.tangent);

float NdotV = max(0.0,dot(normal,view_dir));
float aniso_atten = saturate(sqrt(max(0.0,half_lambert / NdotV ))) * atten; 

float3 aniso_offset = normal * (aniso_noise * _SpecNoise1 + _SpecOffset1);
float3 binormal_aniso = normalize(binormal + aniso_offset);
float3 BdotH = dot(half_dir,binormal_aniso) / _SpecShininess1;
float3 spec_term = exp(-(TdotH * TdotH + BdotH * BdotH)/(1.0 + NdotH));
```