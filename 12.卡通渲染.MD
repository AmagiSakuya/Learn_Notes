# 卡通渲染

### 二色法
```C++
float halfLambert = dot(i.normal,light_dir) * 0.5 + 0.5;
float ramp = smoothstep(0, _ShadowSmooth, halfLambert - _ShadowRange);
float3 diffuseColor = lerp(_ColorShadow, _Color, ramp);
```

### 描边

[更多描边算法](https://zhuanlan.zhihu.com/p/410710318)

```C++
 //描边Pass
Pass
{
    Tags {"LightMode" = "ForwardBase"}

    Cull Front
    //ZWrite On

    CGPROGRAM
    #pragma vertex vert
    #pragma fragment frag
    #include "UnityCG.cginc"

    half _OutlineWidth;
    half4 _OutLineColor;

    struct a2v
    {
        float4 vertex : POSITION;
        float3 normal : NORMAL;
        float2 uv : TEXCOORD0;
        float4 vertColor : COLOR;
        float4 tangent : TANGENT;
    };

    struct v2f
    {
        float4 pos : SV_POSITION;
        float4 vertColor : TEXCOORD0;
    };


    v2f vert(a2v v)
    {
        v2f o;
        UNITY_INITIALIZE_OUTPUT(v2f, o);

        //简单外扩
        o.pos = UnityObjectToClipPos(float4(v.vertex.xyz + v.normal * _OutlineWidth * v.vertColor .a * 0.0001, 1));//顶点沿着法线方向外扩
        o.vertColor = v.vertColor;

        //修正摄像机距离问题
        //float4 pos = UnityObjectToClipPos(v.vertex);
        //float3 viewNormal = mul((float3x3)UNITY_MATRIX_IT_MV, v.normal.xyz);
        //float3 ndcNormal = normalize(TransformViewToProjection(viewNormal.xyz)) * pos.w;//将法线变换到NDC空间
        //pos.xy += 0.01 * _OutlineWidth * ndcNormal.xy;
        //o.pos = pos;
        
        
        return o;
    }

    half4 frag(v2f i) : SV_TARGET
    {
        // return float4(i.vertColor.rgb,1.0)
        return _OutLineColor;
    }
    ENDCG
}
```

### 边缘光优化
```C++
//边缘光
float f = 1.0 - saturate(dot(view_dir, i.normal));
//float rim = smoothstep(_RimAdjustOld.x, _RimAdjustOld.y, f);
//rim = smoothstep(0, _RimAdjustOld.z, rim);
//float3 rimColor = rim * _RimColor.rgb * _RimAdjustOld.a;

//边缘光2 让边缘光来自光照方向
float NdotL = max(0, dot(i.normal, light_dir));
float rimBloom = pow(f, _RimBloomExp) * _RimBloomStrength * NdotL;
float3 rimColor = rimBloom * _RimColor;
```