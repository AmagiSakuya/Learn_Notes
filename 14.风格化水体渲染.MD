# 风格化水体渲染

1. 从深度纹理重建像素的世界空间位置
2. 水面反射与noise
3. GrabPass水底摇动
4. 水底焦散效果
5. 岸边水泡沫与sin波
6. wave顶点动画
7. 水上物体整体跟随

## 从深度纹理重建像素的世界空间位置

[参考连接](https://zhuanlan.zhihu.com/p/92315967)

```C++

v2f vert (appdata v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.screen_pos = ComputeScreenPos(o.pos);
    return o;
}


float4 frag(v2f i) : SV_Target
{
    UNITY_DECLARE_DEPTH_TEXTURE(_CameraDepthTexture);
    float4 _CameraDepthTexture_TexelSize;

    float eyeDepth = SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.screen_pos)).r;
    eyeDepth = LinearEyeDepth(eyeDepth);
    i.worldSpaceDir *= -eyeDepth / i.viewSpaceZ; // Rescale the vector
    float3 worldPos_depth = _WorldSpaceCameraPos + i.worldSpaceDir;
}

```

## Gradient程序化噪点图

```C++
 //https://www.shadertoy.com/view/XdXGW8
float2 GradientNoiseDir(float2 x)
{
    const float2 k = float2(0.3183099, 0.3678794);
    x = x * k + k.yx;
    return -1.0 + 2.0 * frac(16.0 * k * frac(x.x * x.y * (x.x + x.y)));
}

float GradientNoise(float2 UV, float Scale)
{
    float2 p = UV * Scale;
    float2 i = floor(p);
    float2 f = frac(p);
    float2 u = f * f * (3.0 - 2.0 * f);
    return lerp(lerp(dot(GradientNoiseDir(i + float2(0.0, 0.0)), f - float2(0.0, 0.0)),
        dot(GradientNoiseDir(i + float2(1.0, 0.0)), f - float2(1.0, 0.0)), u.x),
        lerp(dot(GradientNoiseDir(i + float2(0.0, 1.0)), f - float2(0.0, 1.0)),
            dot(GradientNoiseDir(i + float2(1.0, 1.0)), f - float2(1.0, 1.0)), u.x), u.y);
}
```

## GerstnerWave

```C++

//https://catlikecoding.com/unity/tutorials/flow/waves/ 模拟水波顶点动画
//https://zhuanlan.zhihu.com/p/435120103
float3 GerstnerWave(float4 wave, float3 position, inout float3 tangent, inout float3 binormal, float waveSpeed, float scale)
{

    float steepness = wave.z / scale;
    float wavelength = wave.w / scale;

    float k = 2 * 3.14 / wavelength;
    float c = sqrt(9.8 / k);
    float2 d = normalize(wave.xy);
    float f = k * (dot(d, position.xz) - (waveSpeed / scale) * _Time.y);
    float a = steepness / k;

    tangent += float3(1 - d.x * d.x * (steepness * sin(f)), d.x * (steepness * cos(f)), -d.x * d.y * (steepness * sin(f)));

    binormal += float3(-d.x * d.y * (steepness * sin(f)), d.y * (steepness * cos(f)), 1 - d.y * d.y * (steepness * sin(f)));

    return float3(d.x * (a * cos(f)), a * sin(f), d.y * (a * cos(f)));
}
```