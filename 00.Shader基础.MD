## 常见基础计算

### 变化矩阵

```
UNITY_MATRIX_MVP 当前的模型观察投影矩阵，用于将顶点/方向矢量从模型空间变换到裁剪空间
UNITY_MATRIX_MV 当前的模型观察矩阵，用于将顶点/方向矢量从模型空间变换到观察空间
UNITY_MATRIX_V 当前的观察矩阵，用于将顶点/方向矢量从世界空间变换到观察空间
UNITY_MATRIX_P 当前的投影矩阵，用于将顶点/方向矢量从观察空间变换到裁剪空间
UNITY_MATRIX_VP 当前的观察投影矩阵，用于将顶点/方向矢量从世界空间变换到裁剪空间
UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵
UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可用于得到UNITY_MATRIX_MV的逆矩阵
```

### 混合模式

```
Blend SrcAlpha OneMinusSrcAlpha // 传统透明度
Blend One OneMinusSrcAlpha // 预乘透明度
Blend One One // 加法
Blend OneMinusDstColor One // 软加法
Blend DstColor Zero // 乘法
Blend DstColor SrcColor // 2x 乘法
```

### Remap
```
float remap(float minOld , float maxOld , float minNew , float maxNew){
    return  (minNew + (_Float0 - minOld) * (maxNew - minNew) / (maxOld - minOld));
}
```

### Fresnel

```C++
  float fresnel =  ( 0.0 + 1.0 * pow( max( 1.0 - dot( view_dir,  normal) , 0.0001 ), 5.0 ) );
```


## 前向渲染

> 注意Tex2D() 和 for循环 耗性能 能少用就少用

### 前向渲染特点
前向渲染的特点为需要两个Pass：
1.每个物体调用ForwardBase的Pass渲染平行光
2.每个物体调用ForwardAdd的Pass叠加方式渲染所有光（包含平行光）
第二个pass采用Blend One One的形式混合

这种渲染模式 算法轻量级 适用于轻量级平台 但光源越多计算量越大
当光源数量超出质量设定里的数量 将采用顶点光模式渲染
增加光强或者更改important可以设定重要程度

### 前向渲染Shader编写格式

```C++
//第一个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardBase"}
    ...
    CGPROGRAM
    #pragma multi_compile_fwdbase // 必须的引用
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
           ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
           ... 
    }
    ...
    ENDCG
}

//第二个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardAdd"}
    Blend One One
    ...
    CGPROGRAM
    // 必须的引用
    #pragma multi_compile_fwdadd 

    #include "UnityCG.cginc"
    #include "AutoLight.cginc"
    #include "Lighting.cginc"
    ...
    // float4 _LightColor0; //  #include "Lighting.cginc" 时则不用定义
    ...
    float4 frag(v2f i) : SV_Target{
            ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
            ... 

            //_WorldSpaceLightPos0.w也可以用于判断光源类型
            #ifdef USING_DIRECTIONAL_LIGHT// AutoLight的宏定义 平行光
            float3 light_dir = normalize(_WorldSpaceLightPos0);
            float attention = 1.0;
            #else // AutoLight的宏定义 点光源
            float3 light_dir = normalize(_WorldSpaceLightPos0 - worldPos);
            float distance = length(_WorldSpaceLightPos0 - worldPos);
            //衰减范围获取（oldVersion） NewVersion参考阴影
            float range = 1.0 / unity_WorldToLight[0][0]; 
            float attention = saturate((range - distance)/range);
            #endif 
    }
    ...
    ENDCG
}
```

## Surface Shader

### 简单结构

```C++
Shader "SurfaceShaderExmaple"
{
	Properties
	{
		...
	}

	SubShader
	{
		Tags{ "RenderType" = "Transparent"  "Queue" = "Transparent+0" "IgnoreProjector" = "True" "IsEmissive" = "true"  }
		Cull Off
		CGPROGRAM
		#include "UnityShaderVariables.cginc"
		#pragma target 3.0
		#pragma surface surf Unlit alpha:fade keepalpha noshadow 
		struct Input
		{
			..
		};

        ...
		uniform sampler2D _NoiseMap;
        ..

		void surf( Input i , inout SurfaceOutput o )
		{
			...
		}

		ENDCG
	}
}
```

### Surface Shader 编译指令

[文档](https://docs.unity3d.com/cn/current/Manual/SL-SurfaceShaders.html)

```
# pragma surface 函数名 lightModel [optionalparams]
```

| lightModel       | 説明                                       |
| :--------------- | :----------------------------------------- |
| Lambert          | ランバート（非PBR）でライティングを計算    |
| BlinnPhong       | ブリンフォン（非PBR）でライティングを計算  |
| Standard         | UnityのStandardシェーダで使っているPBR計算 |
| StandardSpecular | スペキュラセットアップのPBR計算            |


| lightModel       | 输出结构                      |
| :--------------- | :---------------------------- |
| Lambert          | SurfaceOutput                 |
| BlinnPhong       | SurfaceOutput                 |
| Standard         | SurfaceOutputStandard         |
| StandardSpecular | SurfaceOutputStandardSpecular |


### Surface Shader写顶点
```C++
// vertexオプションを追加する
#pragma surface surf Standard vertex:vert
void vert(inout appdata_full v) {
    v.vertex.x += v.vertex.y;
}

//頂点シェーダからsurf関数に値を受け渡す
// 第二引数にInputを指定する
void vert(inout appdata_full v, out Input o) {
    // UNITY_INITIALIZE_OUTPUTでInputを初期化
    UNITY_INITIALIZE_OUTPUT(Input, o);
    // Inputの変数に値を代入
    o.rimColor = float3(1, 0, 0);
}

void surf(Input IN, inout SurfaceOutputStandard o)
{
    // IN.rimColorを使う
    o.Emission = (1 - dot(IN.viewDir, o.Normal)) * IN.rimColor;
}

```

### 输入结构

输入结构 Input 通常具有着色器所需的所有纹理坐标。纹理坐标必须命名为“uv”后跟纹理名称的形式（如果要使用第二个纹理坐标集，则以“uv2”开头）。

| lightModel         | 输出结构                                                                                                                     |
| :----------------- | :--------------------------------------------------------------------------------------------------------------------------- |
| float3 viewDir     | 包含视图方向，用于计算视差效果、边缘光照等等。                                                                               |
| float4 vertexColor : COLOR;      | 包含插值的每顶点颜色。                                                                                                       |
| float4 screenPos   | 包含反射或屏幕空间效果的屏幕空间位置。请注意，这不适合 GrabPass；您需要使用 ComputeGrabScreenPos 函数自己计算自定义 UV。     |
| float3 worldPos    | 包含世界空间位置                                                                                                             |
| float3 worldRefl   | 不写入 o.Normal_ 的情况下，包含世界反射矢量。有关示例，请参阅反光漫射 (Reflect-Diffuse) 着色器。                             |
| float3 worldNormal | 不写入 o.Normal_ 的情况下，包含世界法线矢量                                                                                  |
| float3 worldRefl   | 写入 o.Normal_ 的情况下，包含世界反射矢量。要获得基于每像素法线贴图的反射矢量，请使用 WorldReflectionVector (IN, o.Normal)。 |
| float3 worldNormal | 写入 o.Normal_ 的情况下，包含世界法线矢量。要获得基于每像素法线贴图的法线矢量，请使用 WorldNormalVector (IN, o.Normal)       |


### Surface Shader 输出结构

```c++
struct SurfaceOutput
{
    fixed3 Albedo;  // 漫射颜色
    fixed3 Normal;  // 切线空间法线（如果已写入）
    fixed3 Emission;
    half Specular;  // 0..1 范围内的镜面反射能力
    fixed Gloss;    // 镜面反射强度
    fixed Alpha;    // 透明度 Alpha
};

struct SurfaceOutputStandard
{
    fixed3 Albedo;      // 基础（漫射或镜面反射）颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Metallic;      // 0=非金属，1=金属
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};
struct SurfaceOutputStandardSpecular
{
    fixed3 Albedo;      // 漫射颜色
    fixed3 Specular;    // 镜面反射颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};

```

### 自定义LightMode

> 定义函数 Lighting+名字

#pragma surface surf HalfLambert vertex:vert finalcolor:final

```C++
 half4 LightingHalfLambert(SurfaceOutput s, half3 lightDir, half atten) {
    half ndotl = dot(s.Normal, lightDir);
    half4 c;
    c.rgb = s.Albedo * _LightColor0.rgb * atten * (ndotl * 0.5 + 0.5);
    c.a = s.Alpha;
    return c;
}
```
