## 常见基础计算

### 变化矩阵

```
UNITY_MATRIX_MVP 当前的模型观察投影矩阵，用于将顶点/方向矢量从模型空间变换到裁剪空间
UNITY_MATRIX_MV 当前的模型观察矩阵，用于将顶点/方向矢量从模型空间变换到观察空间
UNITY_MATRIX_V 当前的观察矩阵，用于将顶点/方向矢量从世界空间变换到观察空间
UNITY_MATRIX_P 当前的投影矩阵，用于将顶点/方向矢量从观察空间变换到裁剪空间
UNITY_MATRIX_VP 当前的观察投影矩阵，用于将顶点/方向矢量从世界空间变换到裁剪空间
UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵
UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可用于得到UNITY_MATRIX_MV的逆矩阵
```

### 混合模式

```
Blend SrcAlpha OneMinusSrcAlpha // 传统透明度
Blend One OneMinusSrcAlpha // 预乘透明度
Blend One One // 加法
Blend OneMinusDstColor One // 软加法
Blend DstColor Zero // 乘法
Blend DstColor SrcColor // 2x 乘法
```

### Remap
```
float remap(float minOld , float maxOld , float minNew , float maxNew){
    return  (minNew + (_Float0 - minOld) * (maxNew - minNew) / (maxOld - minOld));
}
```

### Fresnel

```C++
  float fresnel =  ( 0.0 + 1.0 * pow( max( 1.0 - dot( view_dir,  normal) , 0.0001 ), 5.0 ) );
```


## 前向渲染

> 注意Tex2D() 和 for循环 耗性能 能少用就少用

### 前向渲染特点
前向渲染的特点为需要两个Pass：
1.每个物体调用ForwardBase的Pass渲染平行光
2.每个物体调用ForwardAdd的Pass叠加方式渲染所有光（包含平行光）
第二个pass采用Blend One One的形式混合

这种渲染模式 算法轻量级 适用于轻量级平台 但光源越多计算量越大
当光源数量超出质量设定里的数量 将采用顶点光模式渲染
增加光强或者更改important可以设定重要程度

### 前向渲染Shader编写格式

```C++
//第一个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardBase"}
    ...
    CGPROGRAM
    #pragma multi_compile_fwdbase // 必须的引用
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
           ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
           ... 
    }
    ...
    ENDCG
}

//第二个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardAdd"}
    Blend One One
    ...
    CGPROGRAM
    // 必须的引用
    #pragma multi_compile_fwdadd 

    #include "UnityCG.cginc"
    #include "AutoLight.cginc"
    #include "Lighting.cginc"
    ...
    // float4 _LightColor0; //  #include "Lighting.cginc" 时则不用定义
    ...
    float4 frag(v2f i) : SV_Target{
            ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
            ... 

            //_WorldSpaceLightPos0.w也可以用于判断光源类型
            #ifdef USING_DIRECTIONAL_LIGHT// AutoLight的宏定义 平行光
            float3 light_dir = normalize(_WorldSpaceLightPos0);
            float attention = 1.0;
            #else // AutoLight的宏定义 点光源
            float3 light_dir = normalize(_WorldSpaceLightPos0 - worldPos);
            float distance = length(_WorldSpaceLightPos0 - worldPos);
            //衰减范围获取（oldVersion） NewVersion参考阴影
            float range = 1.0 / unity_WorldToLight[0][0]; 
            float attention = saturate((range - distance)/range);
            #endif 
    }
    ...
    ENDCG
}
```

### Surface Shader

参考连接： [Unity-SL-SurfaceShaders](https://docs.unity3d.com/Manual/SL-SurfaceShaders.html)

```C++
Shader "xxx"
{
	Properties
	{
		[HDR]_NoiseMap("_NoiseMap", 2D) = "white" {}
	}

	SubShader
	{
		Tags{ "RenderType" = "Transparent"  "Queue" = "Transparent+0" "IgnoreProjector" = "True" "IsEmissive" = "true"  }
		Cull Off
		CGPROGRAM
		#include "UnityShaderVariables.cginc"
		#pragma target 3.0
		#pragma surface surf Unlit alpha:fade keepalpha noshadow 
		struct Input
		{
			float2 uv_texcoord;
		};


		uniform sampler2D _NoiseMap;

		inline half4 LightingUnlit( SurfaceOutput s, half3 lightDir, half atten )
		{
			return half4 ( 0, 0, 0, s.Alpha );
		}

		void surf( Input i , inout SurfaceOutput o )
		{
			o.Emission = _FireColor.rgb;
			o.Alpha = Opacity95;
		}

		ENDCG
	}
}
```

#### 表面着色器的标准输出结构

```c++
struct SurfaceOutput
{
    fixed3 Albedo;  // 漫射颜色
    fixed3 Normal;  // 切线空间法线（如果已写入）
    fixed3 Emission;
    half Specular;  // 0..1 范围内的镜面反射能力
    fixed Gloss;    // 镜面反射强度
    fixed Alpha;    // 透明度 Alpha
};

struct SurfaceOutputStandard
{
    fixed3 Albedo;      // 基础（漫射或镜面反射）颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Metallic;      // 0=非金属，1=金属
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};
struct SurfaceOutputStandardSpecular
{
    fixed3 Albedo;      // 漫射颜色
    fixed3 Specular;    // 镜面反射颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};

```