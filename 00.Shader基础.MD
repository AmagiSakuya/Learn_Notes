## 01. 前向渲染

> 注意Tex2D() 和 for循环 耗性能 能少用就少用

### 前向渲染特点
前向渲染的特点为需要两个Pass：
1.每个物体调用ForwardBase的Pass渲染平行光
2.每个物体调用ForwardAdd的Pass叠加方式渲染所有光（包含平行光）
第二个pass采用Blend One One的形式混合

这种渲染模式 算法轻量级 适用于轻量级平台 但光源越多计算量越大
当光源数量超出质量设定里的数量 将采用顶点光模式渲染
增加光强或者更改important可以设定重要程度

### 前向渲染Shader编写格式

```C++
//第一个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardBase"}
    ...
    CGPROGRAM
    #pragma multi_compile_fwdbase // 必须的引用
    ...
    float4 _LightColor0;
    ...
    float4 frag(v2f i) : SV_Target{
           ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
           ... 
    }
    ...
    ENDCG
}

//第二个pass
Pass{
    ...
    Tags {"LightMode" = "ForwardAdd"}
    Blend One One
    ...
    CGPROGRAM
    // 必须的引用
    #pragma multi_compile_fwdadd 

    #include "UnityCG.cginc"
    #include "AutoLight.cginc"
    #include "Lighting.cginc"
    ...
    // float4 _LightColor0; //  #include "Lighting.cginc" 时则不用定义
    ...
    float4 frag(v2f i) : SV_Target{
            ...
            _WorldSpaceLightPos0 // 平行光位置
            _LightColor0 // 平行光颜色
            ... 

            //_WorldSpaceLightPos0.w也可以用于判断光源类型
            #ifdef USING_DIRECTIONAL_LIGHT// AutoLight的宏定义 平行光
            float3 light_dir = normalize(_WorldSpaceLightPos0);
            float attention = 1.0;
            #else // AutoLight的宏定义 点光源
            float3 light_dir = normalize(_WorldSpaceLightPos0 - worldPos);
            float distance = length(_WorldSpaceLightPos0 - worldPos);
            //衰减范围获取（oldVersion） NewVersion参考阴影
            float range = 1.0 / unity_WorldToLight[0][0]; 
            float attention = saturate((range - distance)/range);
            #endif 
    }
    ...
    ENDCG
}
```

### Surface Shader

```C++
Shader "Learn/SimpleFire"
{
	Properties
	{
		[HDR]_NoiseMap("_NoiseMap", 2D) = "white" {}
		_UVSpeed("UVSpeed", Vector) = (0,-1,0,0)
		[HDR]_FireColor("FireColor", Color) = (0.8773585,0,0,1)
		_Smooth("Smooth", Float) = 0
		_FireRamp("FireRamp", 2D) = "black" {}
		_FireMask("FireMask", 2D) = "white" {}
		_fireShapeNoise("fireShapeNoise", Float) = 0.02
		[HideInInspector] _texcoord( "", 2D ) = "white" {}
		[HideInInspector] __dirty( "", Int ) = 1
	}

	SubShader
	{
		Tags{ "RenderType" = "Transparent"  "Queue" = "Transparent+0" "IgnoreProjector" = "True" "IsEmissive" = "true"  }
		Cull Off
		CGPROGRAM
		#include "UnityShaderVariables.cginc"
		#pragma target 3.0
		#pragma surface surf Unlit alpha:fade keepalpha noshadow 
		struct Input
		{
			float2 uv_texcoord;
		};

		uniform float4 _FireColor;
		uniform sampler2D _FireMask;
		uniform float4 _FireMask_ST;
		uniform sampler2D _NoiseMap;
		uniform float2 _UVSpeed;
		uniform float4 _NoiseMap_ST;
		uniform float _fireShapeNoise;
		uniform float _Smooth;
		uniform sampler2D _FireRamp;
		uniform float4 _FireRamp_ST;

		inline half4 LightingUnlit( SurfaceOutput s, half3 lightDir, half atten )
		{
			return half4 ( 0, 0, 0, s.Alpha );
		}

		void surf( Input i , inout SurfaceOutput o )
		{
			o.Emission = _FireColor.rgb;
			float2 uv_FireMask = i.uv_texcoord * _FireMask_ST.xy + _FireMask_ST.zw;
			float2 uv_NoiseMap = i.uv_texcoord * _NoiseMap_ST.xy + _NoiseMap_ST.zw;
			float2 panner59 = ( 1.0 * _Time.y * _UVSpeed + uv_NoiseMap);
			float NoiseMap83 = tex2D( _NoiseMap, panner59 ).r;
			float4 appendResult100 = (float4(( uv_FireMask.x + ( (NoiseMap83*2.0 + -1.0) * _fireShapeNoise ) ) , uv_FireMask.y , 0.0 , 0.0));
			float2 uv_FireRamp = i.uv_texcoord * _FireRamp_ST.xy + _FireRamp_ST.zw;
			float smoothstepResult65 = smoothstep( NoiseMap83 , ( NoiseMap83 - _Smooth ) , tex2D( _FireRamp, uv_FireRamp ).r);
			float NoiseUV71 = smoothstepResult65;
			float Opacity95 = ( tex2D( _FireMask, appendResult100.xy ).r * NoiseUV71 );
			o.Alpha = Opacity95;
		}

		ENDCG
	}
	CustomEditor "ASEMaterialInspector"
}
```

#### 表面着色器的标准输出结构

```c++
struct SurfaceOutput
{
    fixed3 Albedo;  // 漫射颜色
    fixed3 Normal;  // 切线空间法线（如果已写入）
    fixed3 Emission;
    half Specular;  // 0..1 范围内的镜面反射能力
    fixed Gloss;    // 镜面反射强度
    fixed Alpha;    // 透明度 Alpha
};

struct SurfaceOutputStandard
{
    fixed3 Albedo;      // 基础（漫射或镜面反射）颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Metallic;      // 0=非金属，1=金属
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};
struct SurfaceOutputStandardSpecular
{
    fixed3 Albedo;      // 漫射颜色
    fixed3 Specular;    // 镜面反射颜色
    fixed3 Normal;      // 切线空间法线（如果已写入）
    half3 Emission;
    half Smoothness;    // 0=粗糙，1=平滑
    half Occlusion;     // 遮挡（默认为 1）
    fixed Alpha;        // 透明度 Alpha
};

```


### 变化矩阵

```
UNITY_MATRIX_MVP 当前的模型观察投影矩阵，用于将顶点/方向矢量从模型空间变换到裁剪空间
UNITY_MATRIX_MV 当前的模型观察矩阵，用于将顶点/方向矢量从模型空间变换到观察空间
UNITY_MATRIX_V 当前的观察矩阵，用于将顶点/方向矢量从世界空间变换到观察空间
UNITY_MATRIX_P 当前的投影矩阵，用于将顶点/方向矢量从观察空间变换到裁剪空间
UNITY_MATRIX_VP 当前的观察投影矩阵，用于将顶点/方向矢量从世界空间变换到裁剪空间
UNITY_MATRIX_T_MV UNITY_MATRIX_MV的转置矩阵
UNITY_MATRIX_IT_MV UNITY_MATRIX_MV的逆转置矩阵，用于将法线从模型空间变换到观察空间，也可用于得到UNITY_MATRIX_MV的逆矩阵
```

### 混合模式

```
Blend SrcAlpha OneMinusSrcAlpha // 传统透明度
Blend One OneMinusSrcAlpha // 预乘透明度
Blend One One // 加法
Blend OneMinusDstColor One // 软加法
Blend DstColor Zero // 乘法
Blend DstColor SrcColor // 2x 乘法
```