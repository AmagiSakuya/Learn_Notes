# 力场护盾

可交互 通过脚本在点击处生成粒子 将粒子参数传入shader shader中循环处理

## 边缘相交检测

```C++
sampler2D _CameraDepthTexture;
void vert (inout appdata_full v, out Input o)
{
    UNITY_INITIALIZE_OUTPUT(Input, o);
    o.proj = ComputeScreenPos(UnityObjectToClipPos(v.vertex));
    COMPUTE_EYEDEPTH(o.proj.z);
}

void surf(Input IN , inout SurfaceOutput o )
{
    //depth
    float m_depth = LinearEyeDepth(SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(IN.proj)).r);
    float distance = (1.0 - (m_depth - IN.proj.z));
    float powDistance = saturate(max(0.001,pow(distance,_DepthFadeDistance)));
}
```

## FlowMap

```C++
float3 FlowMap(float2 uv){
    float2 uv_Flowmap = uv * _FlowLight_ST.xy + _FlowLight_ST.zw;
    uv_Flowmap = (( uv_Flowmap / _Size )).xy;
    float2 flow_Direction = ( (tex2D( _FlowMap, uv )).rg + 0.5 );
    float flow_Distance = _Time.y * _FlowSpeed;
    float frac_flow_Distance = frac( flow_Distance );
    float2 m_uv1 = ( uv_Flowmap + ( flow_Direction * _FlowStrength * frac_flow_Distance ) );
    float2 m_uv2 = ( uv_Flowmap + ( flow_Direction * _FlowStrength * frac( ( flow_Distance + 0.5 ) ) ) );
    float4 result = lerp( tex2D( _FlowLight, m_uv1 ) , tex2D( _FlowLight, m_uv2 ) , ( abs( ( frac_flow_Distance - 0.5 ) ) / 0.5 ));
    return result.rgb;
}
```

## Projection

向量A在向量B上的投影

```
B * dot (A,B) / dot (B,B);
```

## Rejection

向量A在向量B上的投影点指向向量A 可用于平移worldpos 使得顶点计算可以动一个整体

```
A - (B * dot ( A, B) / dot (B ,B);)
```