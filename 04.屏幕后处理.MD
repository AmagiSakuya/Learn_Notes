# 04.屏幕后处理

与普通shader的不同
1. 放置于【Hidden/】层级 不会被普通材质所用
2. SubShader 开启 Cull Off ZWrite Off ZTest Always

## 简洁写法
```C++
#pragma vertex vert_img
half4 frag(v2f_img i) : SV_Target{

}
```
## 解决跨平台坐标不同
```C++
 v2f vert (appdata v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    //解决跨平台坐标不同
    //o.screen_pos = o.pos;
    //o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;
    o.screen_pos = ComputeScreenPos(o.pos);
    return o;
}
```

## 基本颜色调整
```C++
half4 frag(v2f_img i) : SV_Target
    float3 finalColor = col.rgb;
    //色相
    float3 hsv = RGBToHSV(finalColor);
    hsv.r = hsv.r + _HueShift;
    finalColor = HSVToRGB(hsv);
    //亮度
    finalColor *= _Brightness;
    //饱和度
    float lumin = dot(finalColor, float3(0.22, 0.707, 0.071));
    finalColor = lerp(lumin, finalColor, _Saturation);
    //对比度
    float3 midpoint = float3(0.5, 0.5, 0.5);
    finalColor = lerp(midpoint, finalColor, _Contrast);
    //暗角/晕影
    float2 d = abs(i.uv - half2(0.5, 0.5)) * _VignetteIntensity;
    d = pow(saturate(d), _VignetteRoundness);
    float dist = length(d);
    float vfactor = pow(saturate(1.0 - dist * dist), _VignetteSmoothness);
    finalColor = finalColor * vfactor;
    //反色
    //finalColor = 1 - finalColor;
}
```
## 获取屏幕分辨率

```C++
half4 frag(v2f_img i) : SV_Target
    _ScreenParams.x // width 
    _ScreenParams.y // hegiht
}
```

## 使用法线图

```C++
half4 frag(v2f_img i) : SV_Target{
    float aspect = _ScreenParams.x / _ScreenParams.y; // x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height
    float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;

    half glass_opacity = tex2D(_GlassMask, glass_uv).r;
    half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));

    half2 d = 1.0 - smoothstep(0.95,1,abs(i.uv * 2.0 - 1.0));
    half vfactor = d.x * d.y;

    float2 d_mask = step(0.005, abs(glass_normal.xy));
    float mask = d_mask.x * d_mask.y;

    half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;
    half4 col = tex2D(_MainTex, uv_distort);
}
```

## 高斯模糊

> tex2D使用次数过多 性能消耗大 一般配合双重模糊 双重模糊就是在原有模糊原理上 降低RenderTexture采样分辨率多次再提升采样多次 也因此减少了GPU压力

[更多模糊算法](https://zhuanlan.zhihu.com/p/125744132)

[更多模糊算法源码](https://github.com/QianMo/X-PostProcessing-Library/tree/master/Assets/X-PostProcessing/Effects)

```C#
public class BlurPostEffect : MonoBehaviour
{
    public Material ma;

    public float BlurSize = 10;
    public int interator = 2;

    void OnRenderImage(RenderTexture sourceTexture, RenderTexture destTexture)
    {

        ma.SetFloat("_BlurSize", BlurSize);
        int rtW = sourceTexture.width / 8; //降低分辨率 优化性能
        int rtH = sourceTexture.height / 8;

        RenderTexture rtTempA = RenderTexture.GetTemporary(rtW, rtH, 0, sourceTexture.format);
        rtTempA.filterMode = FilterMode.Bilinear;

        RenderTexture rtTempB = RenderTexture.GetTemporary(rtW, rtH, 0, sourceTexture.format);
        rtTempB.filterMode = FilterMode.Bilinear;


        for (int i = 0; i < interator; i++)
        {
            if (0 == i)
            {
                Graphics.Blit(sourceTexture, rtTempA, ma, 0);
                Graphics.Blit(rtTempA, rtTempB, ma, 1);
            }
            else
            {

                Graphics.Blit(rtTempB, rtTempA, ma, 0);
                Graphics.Blit(rtTempA, rtTempB, ma, 1);
            }

        }


        Graphics.Blit(rtTempB, destTexture);

        RenderTexture.ReleaseTemporary(rtTempA);
        RenderTexture.ReleaseTemporary(rtTempB);
    }
}

```

```C++
half4 frag(v2f i) : COLOR {
    // half4 mainColor = tex2D(_MainTex, i.texcoord);

    half4 col = half4(0, 0, 0, 0);
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(-1, -1)) * 1;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(0, -1)) * 2;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(1, -1)) * 1;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(-1, 0)) * 2;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(0, 0)) * 4;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(1, 0)) * 2;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(-1, 1)) * 1;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(0, 1)) * 2;
    col += tex2D(_GrabTexture, i.uvgrab + _GrabTexture_TexelSize.xy * _Range * fixed2(1, 1)) * 1;
    return col / 16;
}

```

### DualKawaseBlur

https://github.com/QianMo/X-PostProcessing-Library/tree/master/Assets/X-PostProcessing/Effects/DualKawaseBlur