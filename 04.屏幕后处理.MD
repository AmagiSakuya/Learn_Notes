# 04.屏幕后处理

与普通shader的不同
1. 放置于【Hidden/】层级 不会被普通材质所用
2. SubShader 开启 Cull Off ZWrite Off ZTest Always

## 简洁写法
```C++
#pragma vertex vert_img
half4 frag(v2f_img i) : SV_Target{

}
```
## 解决跨平台坐标不同
```C++
 v2f vert (appdata v)
{
    v2f o;
    o.pos = UnityObjectToClipPos(v.vertex);
    o.uv = v.texcoord;
    //解决跨平台坐标不同
    //o.screen_pos = o.pos;
    //o.screen_pos.y = o.screen_pos.y * _ProjectionParams.x;
    o.screen_pos = ComputeScreenPos(o.pos);
    return o;
}
```

## 基本颜色调整
```C++
half4 frag(v2f_img i) : SV_Target
    float3 finalColor = col.rgb;
    //色相
    float3 hsv = RGBToHSV(finalColor);
    hsv.r = hsv.r + _HueShift;
    finalColor = HSVToRGB(hsv);
    //亮度
    finalColor *= _Brightness;
    //饱和度
    float lumin = dot(finalColor, float3(0.22, 0.707, 0.071));
    finalColor = lerp(lumin, finalColor, _Saturation);
    //对比度
    float3 midpoint = float3(0.5, 0.5, 0.5);
    finalColor = lerp(midpoint, finalColor, _Contrast);
    //暗角/晕影
    float2 d = abs(i.uv - half2(0.5, 0.5)) * _VignetteIntensity;
    d = pow(saturate(d), _VignetteRoundness);
    float dist = length(d);
    float vfactor = pow(saturate(1.0 - dist * dist), _VignetteSmoothness);
    finalColor = finalColor * vfactor;
    //反色
    //finalColor = 1 - finalColor;
}
```
## 获取屏幕分辨率

```C++
half4 frag(v2f_img i) : SV_Target
    _ScreenParams.x // width 
    _ScreenParams.y // hegiht
}
```

## 使用法线图

```C++
half4 frag(v2f_img i) : SV_Target{
    float aspect = _ScreenParams.x / _ScreenParams.y; // x = width y = height z = 1 + 1.0/width w = 1 + 1.0/height
    float2 glass_uv = float2(i.uv.x * aspect, i.uv.y) * _GlassMask_ST.xy + _GlassMask_ST.zw;

    half glass_opacity = tex2D(_GlassMask, glass_uv).r;
    half3 glass_normal = UnpackNormal(tex2D(_GlassNormal, glass_uv));

    half2 d = 1.0 - smoothstep(0.95,1,abs(i.uv * 2.0 - 1.0));
    half vfactor = d.x * d.y;

    float2 d_mask = step(0.005, abs(glass_normal.xy));
    float mask = d_mask.x * d_mask.y;

    half2 uv_distort = i.uv + glass_normal.xy * _Distort * vfactor * mask;
    half4 col = tex2D(_MainTex, uv_distort);
}
```

## 高斯模糊

> tex2D使用次数过多 性能消耗大 一般配合双重模糊 双重模糊就是在原有模糊原理上 降低RenderTexture采样分辨率多次再提升采样多次 也因此减少了GPU压力

[更多模糊算法](https://zhuanlan.zhihu.com/p/125744132)

[更多模糊算法源码](https://github.com/QianMo/X-PostProcessing-Library/tree/master/Assets/X-PostProcessing/Effects)


### DualKawaseBlur

https://github.com/QianMo/X-PostProcessing-Library/tree/master/Assets/X-PostProcessing/Effects/DualKawaseBlur

https://zhuanlan.zhihu.com/p/499488452

```C#
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace AR_Effect
{
    [RequireComponent(typeof(Camera))]
    public class DualKawaseBlurEffect : MonoBehaviour
    {
        [Range(0.01f, 5)] public float blurSize = 1;
        [Range(0, 10)] public int interator = 1;
        public RenderTexture m_gameBlurOutputTexture;
        public Shader blurShader;
        Material m_blurMat;

        void OnEnable()
        {
            m_blurMat = new Material(blurShader);
        }

        void OnDisable()
        {
            m_blurMat = null;
        }

        RenderTexture rtTempA;
        RenderTexture rtTempB;

        private void OnRenderImage(RenderTexture src, RenderTexture des)
        {

            rtTempA = RenderTexture.GetTemporary(m_gameBlurOutputTexture.width, m_gameBlurOutputTexture.height, 0, m_gameBlurOutputTexture.format);
            rtTempA.filterMode = FilterMode.Bilinear;

            rtTempB = RenderTexture.GetTemporary(m_gameBlurOutputTexture.width, m_gameBlurOutputTexture.height, 0, m_gameBlurOutputTexture.format);
            rtTempB.filterMode = FilterMode.Bilinear;

            Graphics.Blit(src, des);//这一句一定要有，保证画面传递下去。不然会中断camera画面，别的滤镜会失效。    

            Graphics.Blit(src, rtTempA);

            m_blurMat.SetFloat("_Offset", blurSize);


            //DownSample
            for (int i = 0; i < interator; i++)
            {
                Graphics.Blit(rtTempA, rtTempB, m_blurMat, 0);
                Graphics.Blit(rtTempB, rtTempA, m_blurMat, 0);
            }

            //UpSample
            for (int i = 0; i < interator; i++)
            {
                Graphics.Blit(rtTempA, rtTempB, m_blurMat, 1);
                Graphics.Blit(rtTempB, rtTempA, m_blurMat, 1);
            }

            Graphics.Blit(rtTempA, m_gameBlurOutputTexture);

            RenderTexture.ReleaseTemporary(rtTempA);
            RenderTexture.ReleaseTemporary(rtTempB);
        }
    }
}

```

```C++
Shader "Hidden/DualKawaseBlur"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _Offset("Offset",Float) = 0.0
    }
    SubShader
    {
        Tags { "RenderType"="Opaque" }
        LOD 100

        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float4 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float2 uv1 : TEXCOORD1;
                float2 uv2 : TEXCOORD2;
                float2 uv3 : TEXCOORD3;
                float2 uv4 : TEXCOORD4;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            float _Offset;
            float4 _MainTex_TexelSize;//获得纹理纹素值

            v2f vert (appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                #if UNITY_UV_STARTS_TOP
                o.uv.y = 1 - o.uv.y;
                #endif
                //o.uv = TRANSFORM_TEX(v.uv, _MainTex);
                o.uv1 = v.uv + float2(-1, -1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5; //↖
                o.uv2 = v.uv + float2(-1, 1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5; //↙
                o.uv3 = v.uv + float2(1, -1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5; //↗
                o.uv4 = v.uv + float2(1, 1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5; //↘
                return o;
            }

            fixed4 frag (v2f i) : SV_Target
            {
                //降采样
                fixed4 col = tex2D(_MainTex, i.uv) * 4;
                col += tex2D(_MainTex, i.uv1);
                col += tex2D(_MainTex, i.uv2);
                col += tex2D(_MainTex, i.uv3);
                col += tex2D(_MainTex, i.uv4);
                return col * 0.125; //sum / 8.0f
            }
            ENDCG
        }
    
        //升采样
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag

            #include "UnityCG.cginc"

            struct appdata
            {
                float4 vertex : POSITION;
                float4 uv : TEXCOORD0;
            };

            struct v2f
            {
                float2 uv : TEXCOORD0;
                float2 uv1 : TEXCOORD1;
                float2 uv2 : TEXCOORD2;
                float2 uv3 : TEXCOORD3;
                float2 uv4 : TEXCOORD4;
                float2 uv5 : TEXCOORD5;
                float2 uv6 : TEXCOORD6;
                float2 uv7 : TEXCOORD7;
                float4 vertex : SV_POSITION;
            };

            sampler2D _MainTex;
            float4 _MainTex_ST;
            float _Offset;
            float4 _MainTex_TexelSize;//获得纹理纹素值

            v2f vert(appdata v)
            {
                v2f o;
                o.vertex = UnityObjectToClipPos(v.vertex);
                o.uv = v.uv;
                #if UNITY_UV_STARTS_TOP
                o.uv.y = 1 - o.uv.y;
                #endif
                o.uv = v.uv + float2(-1, -1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv1 = v.uv + float2(-1, 1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv2 = v.uv + float2(1, -1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv3 = v.uv + float2(1, 1) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv4 = v.uv + float2(-2, 0) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv5 = v.uv + float2(0, -2) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv6 = v.uv + float2(2, 0) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                o.uv7 = v.uv + float2(0, 2) * (1 + _Offset) * _MainTex_TexelSize.xy * 0.5;
                return o;
            }

            fixed4 frag(v2f i) : SV_Target
            {
                //升采样
                 float4 col = 0;
                 col += tex2D(_MainTex, i.uv) * 2;
                 col += tex2D(_MainTex, i.uv1) * 2;
                 col += tex2D(_MainTex, i.uv2) * 2;
                 col += tex2D(_MainTex, i.uv3) * 2;
                 col += tex2D(_MainTex, i.uv4);
                 col += tex2D(_MainTex, i.uv5);
                 col += tex2D(_MainTex, i.uv6);
                 col += tex2D(_MainTex, i.uv7);
                 return col * 0.0833; //sum / 12.0f
            }
            ENDCG
        }
                
    }
}

```